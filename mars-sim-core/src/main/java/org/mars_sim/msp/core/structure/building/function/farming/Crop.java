/*
 * Mars Simulation Project
 * Crop.java
 * @date 2021-10-21
 * @author Scott Davis
 */
package org.mars_sim.msp.core.structure.building.function.farming;

import java.io.Serializable;
import java.util.List;
import java.util.logging.Level;

import org.mars_sim.msp.core.logging.SimLogger;
import org.mars_sim.msp.core.person.Person;
import org.mars_sim.msp.core.person.ai.task.utils.Worker;
import org.mars_sim.msp.core.resource.ItemResourceUtil;
import org.mars_sim.msp.core.resource.ResourceUtil;
import org.mars_sim.msp.core.structure.building.Building;
import org.mars_sim.msp.core.time.ClockPulse;
import org.mars_sim.msp.core.time.MarsClock;
import org.mars_sim.msp.core.time.MasterClock;
import org.mars_sim.msp.core.tool.RandomUtil;

/**
 * The Crop class describes the behavior of a crop growing on a greenhouse.
 */
public class Crop implements Comparable<Crop>, Serializable {

	/** default serial id. */
	private static final long serialVersionUID = 1L;
	/** default logger. */
	private static SimLogger logger = SimLogger.getLogger(Crop.class.getName());

	private static final double TUNING_FACTOR = 0.2;
	
	private static final int CHECK_HEALTH_FREQUENCY = 20;
	/**
	 * The limiting factor that determines how fast and how much PAR can be absorbed
	 * in one frame.
	 */
	private static final double PHYSIOLOGICAL_LIMIT = 0.9; // 1 is max. if set to 1, a lot of lights will toggle on and
															// off undesirably.
	private static final double RATIO_LEAVES = .75;
	
	/** The average amount of new soil needed needed per square meters. */
	public static final double NEW_SOIL_NEEDED_PER_SQM = .2D;
	/**
	 * The average amount of fertilizers needed when watering (but not needed if
	 * supplied with grey water).
	 */
	public static final double FERTILIZER_NEEDED_WATERING = 0.00005D; // a very minute amount needed per unit time,
																		// called if grey water is not available
	/**
	 * The average amount of fertilizers needed per square meter when planting a new
	 * crop.
	 */
	public static final double FERTILIZER_NEEDED_IN_SOIL_PER_SQM = 1D;

	/**
	 * The ratio of oxygen to carbon during the day when photosynthesis is taking
	 * place and CO2 is absorbed and O2 is generated by the crop.
	 */
	private static final double O2_TO_CO2_RATIO = 44 / 32D;
	/**
	 * The rate of carbon dioxide to oxygen during night time when O2 is absorbed
	 * and CO2 is released by the crop.
	 */
	private static final double CO2_TO_O2_RATIO = 32 / 44D; // 6 CO2 --> 6 O2
	// 6nCO2+5nH2Oâ‡’(C6H10O5)n+6nO2

	// public static final double SOLAR_IRRADIANCE_TO_PAR_RATIO = .42; // only 42%
	// are EM within 400 to 700 nm
	// see
	// http://ccar.colorado.edu/asen5050/projects/projects_2001/benoit/solar_irradiance_on_mars.htm#_top
	// public static final double WATT_TO_PHOTON_CONVERSION_RATIO = 4.609; // in u
	// mol / m2 /s / W m-2 for Mars only

	/** The wattage of a 400W high pressure sodium (HPS) lamp. */
	private static final double KW_PER_HPS = .4;
	/** The lamp efficiency of the high pressure sodium (HPS) lamp. */
	private static final double VISIBLE_RADIATION_HPS = 0.4;
	/** The ballast loss of the high pressure sodium (HPS) lamp. */
	private static final double BALLAST_LOSS_HPS = 0.1;
	/** The non-visible radiation loss of the high pressure sodium (HPS) lamp. */
	private static final double NON_VISIBLE_RADIATION_HPS = .37;
	/** The conduction convection loss of the high pressure sodium (HPS) lamp. */
	private static final double CONDUCTION_CONVECTION_HPS = .13;
	/** The total loss of the high pressure sodium (HPS) lamp. */
	public static final double LOSS_FACTOR_HPS = NON_VISIBLE_RADIATION_HPS * .75 + CONDUCTION_CONVECTION_HPS / 2D;
	/** The minimal amount of resource to be retrieved. */
	private static final double MIN = 0.00001;
	/** The string reference for mushroom */	
	private static final String MUSHROOM = "mushroom";
	
	// public static final double MEAN_DAILY_PAR = 237.2217D ; // in [mol/m2/day]
	// SurfaceFeatures.MEAN_SOLAR_IRRADIANCE * 4.56 * (not 88775.244)/1e6 = 237.2217

	// Data members
	/** The crop identifier (unique only within a greenhouse). */
	private int identifier;
	/** True if this crop is generated at the start of the sim . */
	private boolean isStartup;

	/** True if this crop is a seeded plant. e.g. the sesame plant */
	//private boolean isSeedPlant = false;
	/** The total amount of light received by this crop. */	
	private double effectivePAR;
	/** The ratio between inedible and edible biomass */
	private double massRatio;
	/** The maximum possible harvest for this crop [in kg]. */
	private double maxHarvest;
	/** The remaining possible harvest for this crop [in kg]. */
	private double remainingHarvest;
	/** The completed work time in current phase [in millisols]. */
	private double currentPhaseWorkCompleted = 0;
	/** The daily harvest for crop [in kg/per sol]. */
	private double dailyHarvest;
	/** The maximum possible daily harvest [in kg/per sol]. */
	private double dailyMaxHarvest;
	/** The total amount harvested [in kg]. */
	private double totalHarvest;
	/** The growing phase time completed thus far [in millisols]. */
	private double growingTimeCompleted;
	/** The area occupied by the crop in square meters. */
	private double growingArea;
	/** The total number of growing days [in millisols]. */
	//private double growingTime;
	/** The fraction of the growing time completed. 0 to 1. */
	private double fractionalGrowingTimeCompleted;
	/** The cumulative value of the daily PAR so far. */
	private double cumulativeDailyPAR = 0;
	/** The required power for lighting [in kW]. */
	private double lightingPower = 0;
	/** The health condition factor of the crop. 1 = excellent. 0 = worst*/
	private double healthCondition = 1;
	/** The average water needed [in kg] */
	private double averageWaterNeeded;
	/** The average O2 needed [in kg] */
	private double averageOxygenNeeded;
	/** The average CO2 needed [in kg] */
	private double averageCarbonDioxideNeeded;
	/**
	 * The watt to photon conversion ratio on Mars as defined in crops.xml [in umol
	 * /m^2 /s /(Wm^-2)].
	 */
	private double wattToPhotonConversionRatio;
	/**
	 * The converted value of the watt to photon conversion ratio on Mars as defined
	 * in crops.xml [in umol /m^2 /millisols /(Wm^-2)].
	 */
	private double conversion_factor;
	/** The disease index of a crop */
	private double diseaseIndex = 0;

	private double cumulative_water_usage = 0;

	private double cumulative_o2 = 0;

	private double cumulative_co2 = 0;
	
	private double co2Cache = 0;
	
	private final double co2Threshold;
	
	private double o2Cache = 0;
	
	private final double o2Threshold;
	
	/** The cache values of the pastor environment factors influencing the crop */
	private Double[] environmentalFactor = new Double[] { 
			1.0,   // light, 0
			1.0,   // fertilizer, 1
			1.0,   // temperature, 2
			1.0,   // water, 3
			1.0,   // o2, 4
			1.0 }; // co2, 5

	private CropType cropSpec;

	/** Current phase of crop. */
	private PhaseType phaseType;

	private Farming farm;
	private Building building;

	private final static int WATER_ID = ResourceUtil.waterID;
	private final static int OXYGEN_ID = ResourceUtil.oxygenID;
	private final static int CO2_ID = ResourceUtil.co2ID;
	private final static int GREY_WATER_ID = ResourceUtil.greyWaterID;
	private final static int CROP_WASTE_ID = ResourceUtil.cropWasteID;
	private final static int FERTILIZER_ID = ResourceUtil.fertilizerID;
	
	private final static int MUSHROOM_BOX_ID = ItemResourceUtil.mushroomBoxID;

	private static CropConfig cropConfig;
	

	/**
	 * Constructor.
	 * 
	 * @param identifier      the identifier of this crop.
	 * @param cropType        the type of crop.
	 * @param growingArea     the area occupied by the crop [m^2]
	 * @param dailyMaxHarvest - Maximum possible food harvest for crop. (kg/sol)
	 * @param farm            - Farm crop being grown in.
	 * @param isStartup       - true if this crop is generated at the start of the
	 *                        sim)
	 * @param tissuePercent   the percentage of ticarbonDioxideIDure available based
	 *                        on the requested amount
	 */
	public Crop(int identifier, CropType cropType, double growingArea, double dailyMaxHarvest, Farming farm, 
			boolean isStartup, double tissuePercent) {

		this.identifier = identifier;
		this.cropSpec = cropType;
		this.growingArea = growingArea;
		this.dailyMaxHarvest = dailyMaxHarvest;
		this.farm = farm;
		this.isStartup = isStartup;
		this.co2Threshold = growingArea/10.0;
		this.o2Threshold = growingArea/10.0;

		building = farm.getBuilding();
		List<Phase> phases = cropType.getPhases();

		// Note : growingTime is in millisols
		double growingTime = cropType.getGrowingTime();
		// Note : growingDay in sols
		double growingDay = growingTime / 1000D;
		
		maxHarvest = dailyMaxHarvest * growingDay;
		// Set to zero initially
		remainingHarvest = 0;

		if (cropSpec.getSeedID() > 0) {
			massRatio = 1;
		}

		averageWaterNeeded = cropConfig.getWaterConsumptionRate();
		averageOxygenNeeded = cropConfig.getOxygenConsumptionRate();
		averageCarbonDioxideNeeded = cropConfig.getCarbonDioxideConsumptionRate();
		wattToPhotonConversionRatio = cropConfig.getWattToPhotonConversionRatio();

		conversion_factor = 1000D * wattToPhotonConversionRatio / MarsClock.SECONDS_PER_MILLISOL;

		if (!isStartup) {
			// if this is not a grown crop at the start of the sim, start from the beginning

			if (tissuePercent <= 0) {
				// assume a max 2-day incubation period if no 0% tissue culture is available
				currentPhaseWorkCompleted = 0;
				phaseType = PhaseType.INCUBATION;
				logger.log(building, Level.INFO, 0, " No " + cropSpec.getName() 
						+ " tissue-culture left. Restocking.");
			}

			else if (tissuePercent >= 100) {
				// assume zero day incubation period if 100% tissue culture is available
				currentPhaseWorkCompleted = 0;
				phaseType = PhaseType.PLANTING;
				logger.log(building, Level.INFO, 0, "Done growing " + cropSpec.getName()
						+ "'s tissue-culture. Transferring plantflets to the field.");
				// if it's growing mushroom
				setupMushroom();
			}

			else {
				currentPhaseWorkCompleted = 1000D * phases.get(0).getWorkRequired() * (100D - tissuePercent) / 100D;
				phaseType = PhaseType.INCUBATION;
				logger.log(building, Level.INFO, 0, "A work period of "
								+ Math.round(currentPhaseWorkCompleted / 1000D * 10D) / 10D
								+ " sols is needed to clone enough " + cropSpec.getName() + " tissues before planting.");
			}

		}

		else {
			// This is a grown crop at the start of the sim,
			// Set the percentage of growth randomly
			growingTimeCompleted = RandomUtil.getRandomDouble(growingTime * .95); // for testing only :
																					// growingTimeCompleted =
																					// growingTime - 3000 +
																					// RandomUtil.getRandomDouble(3000D);
																					// or = growingTime * .975;

			fractionalGrowingTimeCompleted = growingTimeCompleted / growingTime;
		
//			 int current = getCurrentPhaseNum();
//			  
//			 if (fractionalGrowingTimeCompleted * 100D > getUpperPercent(current)) {
//				 phaseType = phases.get(current + 1).getPhaseType(); 
//			 }
			
			int size = phases.size();
			for (int i = 0; i < size - 1; i++) {
				if (fractionalGrowingTimeCompleted * 100D > getUpperPercent(i)) {
					phaseType = phases.get(i + 1).getPhaseType();
				}
			}

			// Set the daily harvest
			dailyHarvest = dailyMaxHarvest;
			// Set the remaining harvest based on the fractional growth
			remainingHarvest = maxHarvest * fractionalGrowingTimeCompleted;
		}

	}

	private void setupMushroom() {
		if (cropSpec.getName().toLowerCase().contains(MUSHROOM)) {
			
			if (building.getSettlement().hasItemResource(MUSHROOM_BOX_ID)) {
				building.getSettlement().retrieveItemResource(MUSHROOM_BOX_ID, 1);
			}
			// Require some dead matter for fungi to decompose
			if (growingArea * .5 > MIN)
				retrieve(growingArea * .5, CROP_WASTE_ID, true);
		}
	}

	public double getLightingPower() {
		return lightingPower;
	}

	public double getGrowingArea() {
		return growingArea;
	}

	/**
	 * Gets the crop type that defines this Crop
	 *
	 * @return crop type ID
	 */
	public CropType getCropType() {
		return cropSpec;
	}

	/**
	 * Gets the crop name
	 * 
	 * @return crop name
	 */
	public String getCropName() {
		return cropSpec.getName();
	}
	
	/**
	 * Gets the phase type of the crop.
	 * 
	 * @return phaseType
	 */
	public PhaseType getPhaseType() {
		return phaseType;
	}


	/**
	 * Gets the maximum possible food harvest for crop.
	 * 
	 * @return food harvest (kg.)
	 */
	public double getMaxHarvest() {
		return maxHarvest;
	}

	/**
	 * Gets the amount of growing time completed.
	 * 
	 * @return growing time (millisols)
	 */
	public double getGrowingTimeCompleted() {
		return growingTimeCompleted;
	}

	/**
	 * Checks if crop needs additional work on current sol.
	 * 
	 * @return true if more work needed.
	 */
	public boolean requiresWork() {
		int n = getCurrentPhaseNum();
		if (n == -1)
			return false;
		else if (phaseType == PhaseType.HARVESTING)
			return true;
		else
			return cropSpec.getPhases().get(n).getWorkRequired() * 1000D >= currentPhaseWorkCompleted;
	}

	/**
	 * Tracks the overall health condition of the crop.
	 * 
	 * @return condition as value from 0 (poor) to 1 (healthy)
	 */
	private double trackHealth() {
		// 0:bad, 1:good
		double health = 0D;

		// fractionalGrowingTimeCompleted = growingTimeCompleted/growingTime;

		int current = getCurrentPhaseNum();
//		int length = phases.size();

		if (current < 2) {
			health = 1D;
		}

		else if (current == 2) {
			if (fractionalGrowingTimeCompleted <= .05) {
				// avoid initial spurious data at the start of the sim
				health = 1D;
			} else {
				health = calculateHealth();
			}
		}

//		else if (current > 3 && current < length - 1) {
//			// Including the harvesting phase
//			// Note : the crop will spend most of the time here
//			health = getHealth();
//		}

		else
			health = calculateHealth();

		if (health > 1D)
			health = 1D;
		else if (health < 0D)
			health = 0D;

		if (fractionalGrowingTimeCompleted > .1) {
			// Check on the health of a >10% growing crop
			if (health < .05) {
				logger.log(building, Level.WARNING, 0, "Crop " + cropSpec.getName() 
						+ " died of very poor health (" + Math.round(health * 100D) / 100D + " %)");
				// Add Crop Waste
				double amt = fractionalGrowingTimeCompleted * remainingHarvest * RandomUtil.getRandomDouble(.5);
				if (amt > 0) {
					store(amt, CROP_WASTE_ID, "Crop::trackHealth");
					logger.log(building, Level.WARNING, 0, amt + " kg Crop Waste generated from the dead " + cropSpec.getName());
				}
				phaseType = PhaseType.FINISHED;
			}
		}

		else { // fractionalGrowthCompleted < .1 && fractionalGrowthCompleted > 0D
				// Seedling (<10% grown crop) is less resilient and more prone to environmental
				// factors
			if (health < .2) {
				logger.log(building, Level.WARNING, 0, "The seedlings of " + cropSpec.getName() + " had poor health ("
						+ Math.round(health * 100D) / 100D + " %) and didn't survive.");
				// Add Crop Waste
				double amt = fractionalGrowingTimeCompleted * remainingHarvest * RandomUtil.getRandomDouble(.5);
				if (amt > 0) {
					store(amt, CROP_WASTE_ID, "Crop::trackHealth");
					logger.log(building, Level.WARNING, 0, amt + " kg Crop Waste generated from the dead " + cropSpec.getName());
				}
				phaseType = PhaseType.FINISHED;
			}
		}

		// set healthCondition so that it can be accessed outside of this class
		healthCondition = health;
//		logger.info(cropSpec.getName() + "'s health : " +
//				Math.round(health*100D)/100D);

		return health;
	}

	/*
	 * Computes the health of a crop
	 */
	private double calculateHealth() {
		double health = 0;
		double total = 0;
		int size = environmentalFactor.length;
		for (int i=0; i< size; i++) {		
			if (cropSpec.getCropCategoryType() == CropCategoryType.FUNGI) {
				if (i == 0)
					total = total + 1;
				else
					total = total + environmentalFactor[i];
			}
			
			else {
				total = total + environmentalFactor[i];
			}
		}
		
		// TODO: will need to model diseaseIndex
		health = (1 - diseaseIndex) * total / size;
		
		if (health > 1)
			health = 1;
		
		return health;
	}

	/**
	 * Adds work time to the crops current phase.
	 * 
	 * @param workTime - Work time to be added (millisols)
	 * @return workTime remaining after working on crop (millisols)
	 * @throws Exception if error adding work.
	 */
	public double addWork(Worker worker, double workTime) {
		// Called by Farming's addWork()
		double remainingTime = 0;
		// Note: it's important to set remainingTime initially to zero. If not, addWork will be in endless while loop
		int current = getCurrentPhaseNum();
		List<Phase> phases = cropSpec.getPhases();
		int length = phases.size();
		String name = cropSpec.getName();

		// Improve the health of the crop each time it's being worked on
		if (healthCondition < 1)
			healthCondition += .001 * workTime;
		if (healthCondition > 1)
			healthCondition = 1;
		
		double w = phases.get(current).getWorkRequired() * 1000D;

		if (dailyHarvest < 0D) {
			dailyHarvest = 0;
			growingTimeCompleted = 0;
		}

		if (current == 0 && current == 1) {
			// at a particular growing phase (NOT including the harvesting phase)
			currentPhaseWorkCompleted += workTime;

			if (currentPhaseWorkCompleted >= w * 1.01) {
				remainingTime = currentPhaseWorkCompleted - w;
				currentPhaseWorkCompleted = 0D;
				phaseType = phases.get(current + 1).getPhaseType();
				logger.log(building, Level.FINE, 0, name + " had entered a new phase " + phaseType
						+ "   Work Completed : " + Math.round(currentPhaseWorkCompleted * 10D) / 10D
						+ "   Work Required : " + Math.round(w * 10D) / 10D);
			}
		}

		else if (current < length - 2) {
			// at a particular growing phase (NOT including the harvesting phase)
			currentPhaseWorkCompleted += workTime;

			if (currentPhaseWorkCompleted >= w * 1.01) {
				remainingTime = currentPhaseWorkCompleted - w;
				currentPhaseWorkCompleted = 0D;
				// phaseType = phases.get(current + 1).getPhaseType();
			}
		}

		else if ((current == length - 2) && fractionalGrowingTimeCompleted > 1.15)  {
			logger.log(building, Level.FINE, 0, name + "'s fractionalGrowingTimeCompleted is " + fractionalGrowingTimeCompleted + "  Setting the phase to FINISHED.");
			phaseType = PhaseType.FINISHED;	
		}
		
		// TODO: for leaves crop, one should be able to harvest leaves ANYTIME and NOT
		// to have to wait until harvest
		else if (current == length - 2 || current == length - 3) {
			// at the maturation or harvesting phase
			currentPhaseWorkCompleted += workTime;
			// Set the harvest multiplier
			int multiplier = 5;
			
			if (currentPhaseWorkCompleted >= w * 1.01) {
				// Harvest is over. Close out this phase
				double overWorkTime = currentPhaseWorkCompleted - w;
				// Modify parameter list to include crop name
				double lastHarvest = multiplier * dailyHarvest * workTime / w;

				if (remainingHarvest > 0) {
					collectProduce(lastHarvest);

					remainingHarvest -= lastHarvest;					
					totalHarvest += lastHarvest;
					
					remainingTime = overWorkTime;

					// Don't end until there is nothing left ?
					if (remainingHarvest <= 0) {
						logger.log(building, worker, Level.INFO, 0, "Harvested a total of "
									+ Math.round(totalHarvest * 100.0) / 100.0 + " kg "
									+ name + ".", null);
						
						if (current == length - 3)
							logger.log(building, worker, Level.INFO, 0, "Closed out the initial harvest of " 
									+ name + ".", null);
	
						else if (current == length - 2)
							logger.log(building, worker, Level.INFO, 0, "Closed out the final harvest of " 
									+ name + ".", null);
						
						// Reset the totalHarvest back to zero.
						totalHarvest = 0;
						// Sets the phase to FINISHED
						phaseType = PhaseType.FINISHED;
						
						//  Check to see if a botany lab is available
						if (worker instanceof Person && !farm.checkBotanyLab(cropSpec, worker))
							logger.log(building, worker, Level.INFO, 0, 
									"Can't find an available lab bench to work on the tissue culture for " 
											+ name + ".", null);
					}
				}
				
			}

			else {

				if (dailyHarvest > 0.00001) {
					// Continue the harvesting process
					double modifiedHarvest = multiplier * dailyHarvest * workTime / w;
					// Store the crop harvest
					if (modifiedHarvest > 0 && remainingHarvest > 0) {
						collectProduce(modifiedHarvest);

						remainingHarvest -= modifiedHarvest;
						
						totalHarvest += modifiedHarvest;
					}

					remainingTime = 0D;
				}
			}
		}

		return remainingTime;
	}

	private void collectProduce(double harvestMass) {
		boolean isSeedPlant = cropSpec.isSeedPlant();
		int seedID = cropSpec.getSeedID();
		int cropID = cropSpec.getCropID();
		String source = "Crop::addWork";
		
		if (isSeedPlant) {
			// Extract Sesame Seed. 
			// Note the purpose for this plant is primarily the seeds 
			store(harvestMass, seedID, source);
		}
		else if ((seedID > 0) && harvestMass * massRatio > 0) {
			// White Mustard has leaves as food. Also extract Mustard Seed
			store(harvestMass * massRatio, seedID, source);
			store(harvestMass, cropID, source);
		}
		else {
			store(harvestMass, cropID, source);
		}

		// Calculate the amount of leaves and crop wastes that are generated
		double inedible = harvestMass / cropSpec.getEdibleBiomass() * cropSpec.getInedibleBiomass();
		double cropWaste = inedible * RATIO_LEAVES;
		if (cropWaste > 0) {
			store(cropWaste, CROP_WASTE_ID, "Crop::generateCropWaste");
		}
		
		if (cropSpec.getCropCategoryType() == CropCategoryType.LEAVES) {
			double leaves = inedible - cropWaste;
			if (leaves > 0) {
				store(leaves, ResourceUtil.leavesID, "Crop::generateCropWaste");
			}
		}
	}
	
	private void updateUsage(int currentSol) {
		String name = cropSpec.getName();
//		if (cumulative_water_usage > 0) {
			// Records the water usage per crop in the farm
			farm.addCropUsage(name, cumulative_water_usage, currentSol, 0);
			// Reset the water usage
			cumulative_water_usage = 0;
//		}

//		if (cumulative_o2 > 0) {
			// Records the CO2 consumption/generation in the farm
			farm.addCropUsage(name, cumulative_o2, currentSol, 1);
			// Reset the consumption/generation
			cumulative_o2 = 0;
//		}

//		if (cumulative_co2 > 0) {
			// Records the oxygen consumption/generation in the farm
			farm.addCropUsage(name, cumulative_co2, currentSol, 2);
			// Reset the consumption/generation
			cumulative_co2 = 0;
//		}
	}
	
	/**
	 * Time passing for crop.
	 * @param solarIrradiance 
	 * @param greyFilterRate 
	 * @param temperatureModifier 
	 * 
	 * @param time - amount of time passing (millisols)
	 */
	public boolean timePassing(ClockPulse pulse, double productionLevel,
							   double solarIrradiance, double greyFilterRate,
							   double temperatureModifier) {

		int current = getCurrentPhaseNum();
		List<Phase> phases = cropSpec.getPhases();
		int length = phases.size();
		double time = pulse.getElapsed() * productionLevel;

		fractionalGrowingTimeCompleted = growingTimeCompleted / cropSpec.getGrowingTime();

		growingTimeCompleted += time;

//		if (current > 1 && current < length - 1) {
			// From phase 2 to harvesting phase
			//if (pulse.getElapsed() > 0D) {
				// growingTimeCompleted += time;		
				
			if (current < length - 2) {
				// Right before the harvesting phase
				if (fractionalGrowingTimeCompleted * 100D > getUpperPercent(current)) {
					// Advance onto the next phase
					phaseType = phases.get(current + 1).getPhaseType();
				}
			}

			// check for the passing of each day
			if (pulse.isNewSol()) {

				// double maxDailyHarvest = maxHarvest / cropGrowingDay;
//					double w = phases.get(current).getWorkRequired() * 1000D;
//					// Calculate the daily work completed
//					double dailyWorkCompleted = currentPhaseWorkCompleted / w;
//					// Modify actual harvest amount based on daily tending work.
//					dailyHarvest += (dailyMaxHarvest * (dailyWorkCompleted - .5D));
				
				// Resets the daily harvest back to zero
				dailyHarvest = 0;
				
				// Update the resource usage
				updateUsage(pulse.getMarsTime().getMissionSol());

				if (dailyHarvest < 0) {
					phaseType = PhaseType.FINISHED;
					dailyHarvest = 0;
					return true;
				}
				// Note: is it better off doing the actualHarvest computation once a day or
				// every time
				// Reset the daily work counter currentPhaseWorkCompleted back to zero
				// currentPhaseWorkCompleted = 0D;
				cumulativeDailyPAR = 0;
			}

			int msol = pulse.getMarsTime().getMillisolInt();
			if (msol % CHECK_HEALTH_FREQUENCY == 0) {
				// Checks on crop health
				trackHealth();
			}

			// max possible harvest within this period of time
			double maxPeriodHarvest = maxHarvest * (time / cropSpec.getGrowingTime());
			// Compute each harvestModifiers and sum them up below
			// Note: computeHarvest takes up 40% of all cpu utilization
			double harvestModifier = computeHarvest(maxPeriodHarvest, pulse, time,
													solarIrradiance,
													greyFilterRate,
													temperatureModifier);
			// Add to the daily harvest.
			dailyHarvest += maxPeriodHarvest * harvestModifier;
			// Add to the cumulative harvest.				
			remainingHarvest += maxPeriodHarvest * harvestModifier;
			
			if (dailyHarvest < 0) {
				phaseType = PhaseType.FINISHED;
				dailyHarvest = 0;
				return true;
			}
			

			if (fractionalGrowingTimeCompleted > 1.1) {
				phaseType = PhaseType.FINISHED;
				totalHarvest = 0;
				return true;
			}
			
//		}

		else if (phaseType == PhaseType.FINISHED) {
			dailyHarvest = 0;
			totalHarvest = 0;
			growingTimeCompleted = 0;
		}
		return true;
	}

	private void turnOnLighting(double kW) {
		lightingPower = kW;
	}

	private void turnOffLighting() {
		lightingPower = 0;
	}

	/**
	 * Computes the effects of the available sunlight and artificial light
	 * 
	 * @param time
	 * @param solarIrradiance 
	 * @return instantaneous PAR or uPAR
	 */
	private double computeLight(ClockPulse pulse, double time, double solarIrradiance) {
		double lightModifier = 0;

		int msols = pulse.getMarsTime().getMillisolInt();
		// Note : The average PAR is estimated to be 20.8 mol/(mÂ² day) (Gertner, 1999)
		// Calculate instantaneous PAR from solar irradiance
		double uPAR = wattToPhotonConversionRatio * solarIrradiance;
		// [umol /m^2 /s] = [u mol /m^2 /s /(Wm^-2)] * [Wm^-2]
		double PAR_interval = uPAR / 1_000_000D * time * MarsClock.SECONDS_PER_MILLISOL; // in mol / m^2 within this
		
		double dailyPARRequired = cropSpec.getDailyPAR();
		// period of time
		// [mol /m^2] = [umol /m^2 /s] / u * [millisols] * [s /millisols]
		// 1 u = 1 micro = 1/1_000_000
		// Note : daily-PAR has the unit of [mol /m^2 /day]
		// Gauge if there is enough sunlight
		double progress = cumulativeDailyPAR / dailyPARRequired; // [max is 1]

		double clock = msols / 1000D; // [max is 1]

		// When enough PAR have been administered to the crop, the HPS_LAMP will turn
		// off.
		// TODO: what if the time zone of a settlement causes sunlight to shine at near
		// the tail end of the currentMillisols time ?
		// Compared cumulativeDailyPAR / dailyPARRequired vs. current time /
		// 1000D
		// Reduce the frequent toggling on and off of lamp and to check on
		// the time of day to anticipate the need of sunlight.
		if (0.5 * progress < clock && msols <= 333 || 0.7 * progress < clock && msols > 333 && msols <= 666
				|| progress < clock && msols > 666) {
			// TODO: also compare also how much more sunlight will still be available
			if (uPAR > 40) { // if sunlight is available
				turnOffLighting();
				cumulativeDailyPAR = cumulativeDailyPAR + PAR_interval;
				// Gets the effectivePAR
				effectivePAR = PAR_interval;	 
			}

			else { // if no sunlight, turn on artificial lighting
					// double conversion_factor = 1000D * wattToPhotonConversionRatio /
					// MarsClock.SECONDS_IN_MILLISOL ;
					// DLI is Daily Light Integral is the unit for for cumulative light -- the
					// accumulation of all the PAR received during a day.
				double DLI = dailyPARRequired - cumulativeDailyPAR; // [in mol / m^2 / day]
				double delta_PAR_outstanding = DLI * (time / 1000D) * growingArea;
				// in mol needed at this delta time [mol] = [mol /m^2 /day] * [millisol] /
				// [millisols /day] * m^2
				double delta_kW = delta_PAR_outstanding / time / conversion_factor;
				// [kW] = [mol] / [u mol /m^2 /s /(Wm^-2)] / [millisols] / [s /millisols] = [W
				// /u] * u * k/10e-3 = [kW]; since 1 u = 10e-6
				// TODO: Typically, 5 lamps per square meter for a level of ~1000 mol/ m^2 /s
				// Added PHYSIOLOGICAL_LIMIT sets a realistic limit for tuning how
				// much PAR a food crop can absorb per frame.
				// Note 1 : PHYSIOLOGICAL_LIMIT minimize too many lights turned on and off too
				// frequently
				// Note 2 : It serves to smooth out the instantaneous power demand over a period
				// of time
				// each HPS_LAMP lamp supplies 400W has only 40% visible radiation efficiency
				int numLamp = (int) (Math.ceil(
						delta_kW / KW_PER_HPS / VISIBLE_RADIATION_HPS / (1 - BALLAST_LOSS_HPS) * PHYSIOLOGICAL_LIMIT));
				// TODO: should also allow the use of LED_KIT for lighting
				// For converting lumens to PAR/PPF, see
				// http://www.thctalk.com/cannabis-forum/showthread.php?55580-Converting-lumens-to-PAR-PPF
				// Note: do NOT include any losses below
				double supplykW = numLamp * KW_PER_HPS * VISIBLE_RADIATION_HPS * (1 - BALLAST_LOSS_HPS)
						/ PHYSIOLOGICAL_LIMIT;
				turnOnLighting(supplykW);
				double delta_PAR_supplied = supplykW * time * conversion_factor / growingArea; // in mol / m2
				// [ mol / m^2] = [kW] * [u mol /m^2 /s /(Wm^-2)] * [millisols] * [s /millisols]
				// / [m^2] = k u mol / W / m^2 * (10e-3 / u / k) = [mol / m^-2]
				cumulativeDailyPAR = cumulativeDailyPAR + delta_PAR_supplied + PAR_interval;
				// [mol /m^2 /d]
				
				// Gets the effectivePAR
				effectivePAR = delta_PAR_supplied + PAR_interval;				 
			}
		}

		else {
			turnOffLighting();
		}

		// check for the passing of each day
		int newSol = pulse.getMarsTime().getMissionSol();
		// the crop has memory of the past lighting condition
		lightModifier = cumulativeDailyPAR / (dailyPARRequired + .0001) * 1000D / ( msols  + .0001);
		// TODO: If too much light, the crop's health may suffer unless a person comes
		// to intervene
		if (isStartup && newSol == 1) {
			// if this crop is generated at the start of the sim, 
			// lightModifier should start from 1, rather than 0
			lightModifier = 1;
		}
		
		adjustEnvironmentFactor(lightModifier, 0);

		return uPAR;

	}


	/***
	 * Computes the effect of water and fertilizer
	 * 
	 * @param needFactor
	 * @param time
	 * @param greyFilterRate 
	 */
	private void computeWaterFertilizer(double needFactor, double time, double greyFilterRate) {
		// Calculate water usage kg per sol
		double waterRequired =  TUNING_FACTOR * needFactor * (averageWaterNeeded * time / 1_000D) * growingArea; // fractionalGrowingTimeCompleted
//		System.out.println(getCropType() + "  waterRequired : " + waterRequired);
		// Determine the amount of grey water available.
		double gw = building.getSettlement().getAmountResourceStored(GREY_WATER_ID);
		double greyWaterAvailable = Math.min(gw * greyFilterRate * time, gw);
		double waterUsed = 0;
		double greyWaterUsed = 0;
//		double totalWaterUsed = 0;

		double waterModifier = 0;
		double fertilizerModifier = 0;

		// First water crops with grey water if it is available.
		if (greyWaterAvailable >= waterRequired) {
			greyWaterUsed = waterRequired;
//			totalWaterUsed = greyWaterUsed;
			if (greyWaterUsed > MIN)
				retrieve(greyWaterUsed, GREY_WATER_ID, true);
			// TODO: track grey water as well ?
			waterModifier = 1D;
		}

		else if (greyWaterAvailable < waterRequired) {
			// If not enough grey water, use water
			greyWaterUsed = greyWaterAvailable;
			if (greyWaterUsed > MIN)
				retrieve(greyWaterUsed, GREY_WATER_ID, true);
			// TODO: track grey water as well ?
			waterRequired = waterRequired - greyWaterUsed;
			double waterAvailable = building.getSettlement().getAmountResourceStored(WATER_ID);
			
			if (waterAvailable >= waterRequired) {
				waterUsed = waterRequired;
				if (waterUsed > MIN) {
					retrieve(waterUsed, WATER_ID, true);
					//  Records the daily water usage in the farm
					farm.addDailyWaterUsage(waterUsed);
				}
				
				waterModifier = 1D;
			}
			else {
				// not enough water
				waterUsed = waterAvailable;
				if (waterUsed > MIN) {
					retrieve(waterUsed, WATER_ID, true);
					//  Records the daily water usage in the farm
					farm.addDailyWaterUsage(waterUsed);
				}
				// Incur penalty if water is NOT available
				// need to add .0001 in case waterRequired becomes zero
				waterModifier = (greyWaterUsed + waterUsed) / (waterRequired + .0001);
			}

			double fertilizerAvailable = building.getSettlement().getAmountResourceStored(FERTILIZER_ID);
			// The amount of fertilizer to be used depends on the ratio of the grey water used
			double fertilizerRequired = FERTILIZER_NEEDED_WATERING * time * greyWaterUsed / (greyWaterUsed + waterUsed + .0001);
			double fertilizerUsed = fertilizerRequired;

			if (fertilizerUsed > fertilizerAvailable) {
				// not enough fertilizer
				fertilizerUsed = fertilizerAvailable;
				// should incur penalty due to insufficient fertilizer
				fertilizerModifier = fertilizerUsed / ( fertilizerRequired + 0.0001);
			} else {
				// there's enough fertilizer
				fertilizerModifier = 1D;
			}

			if (fertilizerUsed > MIN) {
				retrieve(fertilizerUsed, FERTILIZER_ID, true);
			}

			adjustEnvironmentFactor(fertilizerModifier, 1);

		}

		// Amount of water reclaimed through a Moisture Harvesting System inside the
		// Greenhouse
		// TODO: Modify harvest modifier according to the moisture level
		// double waterReclaimed = totalWaterUsed * growingArea * time / 1000D *
		// MOISTURE_RECLAMATION_FRACTION;
		// if (waterReclaimed > 0)
		// Storage.storeAnResource(waterReclaimed, waterID, inv, sourceName +
		// "::computeWaterFertilizer");

		// Assume an universal rate of water vapor evaporation rate of 5%
		// farm.addMoisture(totalWaterUsed*.05);
		// Record the amount of water taken up by the crop
		cumulative_water_usage = cumulative_water_usage + waterUsed;// * .95;

		adjustEnvironmentFactor(waterModifier, 3);

	}

	/***
	 * Computes the effects of the concentration of O2 and CO2
	 * 
	 * @param uPAR
	 * @param needFactor
	 * @param maxPeriodHarvest
	 * @param time
	 */
	private void computeGases(double uPAR, double needFactor, double time) {
		double watt = uPAR / time / conversion_factor * growingArea * 1000; 
//		System.out.println("uPAR : " + uPAR + "  Watt : " + watt);
		// Note: uPAR includes both sunlight and artificial light
		// Calculate O2 and CO2 usage kg per sol
		double o2Modifier = 0, co2Modifier = 0;
		double fudge_factor = 0;

		if (watt < 40) {
//			if (uPAR == 0)
				fudge_factor = 2.5;
//			else if (uPAR == 40)
//				fudge_factor = 2.5;
//			else
//				fudge_factor = 5 - 2.5 * uPAR / 40;
//			
//			if (fudge_factor < 0)
//				fudge_factor = 0;
			
			double o2Required = fractionalGrowingTimeCompleted * fudge_factor * needFactor
					* (averageOxygenNeeded * time / 1000) * growingArea;
			double o2Available = building.getSettlement().getAmountResourceStored(OXYGEN_ID);
			double o2Used = o2Required;

			o2Modifier = o2Available / o2Required;

			if (o2Used > o2Available)
				o2Used = o2Available;
			if (o2Used > MIN) {
				retrieveO2(o2Used);
				// farm.addO2Cache(-o2Used);
				cumulative_o2 = cumulative_o2 - o2Used;
			}

//			o2Modifier = o2Used / o2Required;

			adjustEnvironmentFactor(o2Modifier, 4);

			// Determine the amount of co2 generated via gas exchange.
			double cO2Gen = o2Used * CO2_TO_O2_RATIO;
			if (cO2Gen > MIN) {
				storeCO2(cO2Gen);
				// farm.addCO2Cache(cO2Gen);
				cumulative_co2 = cumulative_co2 + cO2Gen;
			}
		}

		else {
			// during the day
			fudge_factor = .0185 * watt + 1.76;
			// TODO: gives a better modeling of how the amount of light available will
			// trigger photosynthesis that converts co2 to o2
			// Determine harvest modifier by amount of carbon dioxide available.
			double cO2Req = fractionalGrowingTimeCompleted * fudge_factor * needFactor
					* (averageCarbonDioxideNeeded * time / 1000) * growingArea;
			double cO2Available = building.getSettlement().getAmountResourceStored(CO2_ID);
			double cO2Used = cO2Req;

			// TODO: allow higher concentration of co2 to be pumped to increase the harvest
			// modifier to the harvest.

			co2Modifier = cO2Available / cO2Req;
			
			if (cO2Used > cO2Available)
				cO2Used = cO2Available;
			if (cO2Used > MIN) {
				retrieveCO2(cO2Used);
				cumulative_co2 = cumulative_co2 - cO2Used;
			}
			// Note: research how much high amount of CO2 may facilitate the crop growth and
			// reverse past bad health

//			co2Modifier = cO2Used / cO2Req;

			adjustEnvironmentFactor(co2Modifier, 5);

			// 6CO2 + 6H2O + sunlight -> C6H12O6 + 6O2
			//
			// Determine the amount of oxygen generated during the day when photosynthesis
			// is taking place .
			double o2Gen = cO2Used * O2_TO_CO2_RATIO;
			if (o2Gen > 0) {
				storeO2(o2Gen);
				cumulative_o2 = cumulative_o2 + o2Gen;
			}
		}

	}

	/**
	 * Adjust the environmental factors
	 * 
	 * @param mod the modifier of interest
	 * @param type the 
	 */
	private void adjustEnvironmentFactor(double mod, int type) {
		double f = environmentalFactor[type];
		f = 0.01 * mod + 0.99 * f;
		if (f > 1.25)
			f = 1.25;	
		else if (f < 0.1 || Double.isNaN(f))
			f = 0.1;
		environmentalFactor[type] = f;
	}
	
	/**
	 * Computes each input and output constituent for a crop for the specified
	 * period of time and return the overall harvest modifier
	 * @param solarIrradiance 
	 * @param greyFilterRate 
	 * @param temperatureModifier 
	 * 
	 * @param the maximum possible growth/harvest
	 * @param a   period of time in millisols
	 * @return the harvest modifier
	 */
	private double computeHarvest(double maxPeriodHarvest, ClockPulse pulse,
						double time, double solarIrradiance, double greyFilterRate, double temperatureModifier) {

		double harvestModifier = 1D;

		// TODO: use theoretical model for crop growth, instead of empirical model
		// below.
		// TODO: the calculation should be uniquely tuned to each crop
		// TODO: Modify harvest modifier according to the pollination by the number of
		// bees in the greenhouse
		// TODO: Modify harvest modifier by amount of artificial light available to the
		// whole greenhouse

		int phaseNum = getCurrentPhaseNum();
		int length = cropSpec.getPhases().size();

		// Tune the growthFactor according to the stage of a crop
		double growthFactor = 5;
		// amount of grey water/water needed is also based on % of growth
		if (phaseNum == 2)
			// if (phaseType == PhaseType.GERMINATION)
			growthFactor = .2;
		else if (fractionalGrowingTimeCompleted < .1)
			growthFactor = .3;
		else if (fractionalGrowingTimeCompleted < .15)
			growthFactor = .4;
		else if (fractionalGrowingTimeCompleted < .2)
			growthFactor = .5;
		else if (phaseNum > 2 && phaseNum < length - 2)
			growthFactor = fractionalGrowingTimeCompleted;
		else if (phaseType == PhaseType.FINISHED)
			growthFactor = .4;

		// STEP 1 : COMPUTE THE EFFECTS OF THE SUNLIGHT AND ARTIFICIAL LIGHT
		double uPAR = 0;

		if (cropSpec.getCropCategoryType() == CropCategoryType.FUNGI) {// cropSpec.getName().contains("mushroom")) {
			environmentalFactor[0] = 1D;
			// Set uPAR to zero since mushrooms are fungi, neeed no sunlight
			// Fungi consumes O2 and release CO2
			uPAR = 0;
		} else {
			uPAR = computeLight(pulse, time, solarIrradiance);
		}
		
		// STEP 2 : COMPUTE THE EFFECTS OF THE TEMPERATURE
		adjustEnvironmentFactor(temperatureModifier, 2);

		// STEP 3 : COMPUTE THE EFFECTS OF THE WATER AND FERTIZILER
		computeWaterFertilizer(growthFactor, time, greyFilterRate);

		// STEP 4 : COMPUTE THE EFFECTS OF GASES (O2 and CO2 USAGE)
		// Note: computeGases takes up 25% of all cpu utilization
		computeGases(effectivePAR, growthFactor, time);
		// Note that mushrooms are fungi and consume O2 and release CO2

		// TODO: add air pressure modifier in future

		// Tune harvestModifier
		// Note that light is the dorminant environmental factor
		if (phaseNum > 2 && phaseNum < length - 2) {
			harvestModifier = .6 * harvestModifier + .4 * harvestModifier * environmentalFactor[0];
		} else if (phaseNum == 2)
			harvestModifier = .8 * harvestModifier + .2 * harvestModifier * environmentalFactor[0];

		harvestModifier = .25 * harvestModifier + .15 * harvestModifier * environmentalFactor[1]
				+ .15 * harvestModifier * environmentalFactor[2] + .15 * harvestModifier * environmentalFactor[3]
				+ .15 * harvestModifier * environmentalFactor[4] + .15 * harvestModifier * environmentalFactor[5];

		// TODO: research how the above 6 factors may affect crop growth for different
		// crop categories

		return harvestModifier;
	}

	/**
	 * Get the current growing phase id of the Crop
	 * @return
	 */
	int getCurrentPhaseNum() {
		int idx = 0;
		for (Phase entry : cropSpec.getPhases()) {
			if (entry.getPhaseType() == phaseType) {
				return idx;
			}
			idx++;
		}
		return -1;
	}

	/**
	 * Gets the upper limit percentage of the phase
	 */
	private double getUpperPercent(int phase) {
		double result = 0;
		List<Phase> phases = cropSpec.getPhases();
		for (int i = 1; i < phase + 1; i++) {
			if (phases.get(i) != null)
				result = result + phases.get(i).getPercentGrowth();
		}
		return result;
	}

	public void resetPAR() {
		cumulativeDailyPAR = 0;
	}

	public double getHealthCondition() {
		return healthCondition;
	}

	public double getPercentGrowth() {
		return  Math.round(fractionalGrowingTimeCompleted * 1_000.0)/10.0;
	}

	public int getIdentifier() {
		return identifier;
	}
	
	/**
	 * Retrieve the carbon dioxide
	 * 
	 * @param amount
	 * @return
	 */
	private boolean retrieveCO2(double amount) {
		boolean result = false;
		if (co2Cache - amount < -co2Threshold) {
			result = retrieve(co2Cache, CO2_ID, true);
			co2Cache = -amount;
		}
		else {
			co2Cache -= amount;
		}
		return result;
	}
	
	/**
	 * Retrieve the oxygen 
	 * 
	 * @param amount
	 * @return
	 */
	private boolean retrieveO2(double amount) {
		boolean result = false;
		if (o2Cache - amount < -o2Threshold) {
			result = retrieve(o2Cache, OXYGEN_ID, true);
			o2Cache = -amount;
		}
		else {
			o2Cache -= amount;
		}
		return result;
	}
	
	/**
	 * Retrieves the amount resource
	 * 
	 * @param amount
	 * @param resource
	 * @param value
	 * @return
	 */
	private boolean retrieve(double amount, int resource, boolean value) {
		if (building.getSettlement().retrieveAmountResource(resource, amount) == 0)
			return true;
		return false;
	}
	
	/**
	 * Stores the carbon dioxide
	 * 
	 * @param amount
	 * @return
	 */
	private boolean storeCO2(double amount) {
		boolean result = false;
		if (co2Cache + amount > co2Threshold) {
			result = store(co2Cache, CO2_ID, "Crop::computeGases");
			co2Cache = amount;
		}
		else {
			co2Cache -= amount;
		}
		return result;
	}

	/**
	 * Stores the oxygen
	 * 
	 * @param amount
	 * @return
	 */
	private boolean storeO2(double amount) {
		boolean result = false;
		if (o2Cache + amount > o2Threshold) {
			result = store(o2Cache, OXYGEN_ID, "Crop::computeGases");
			o2Cache = amount;
		}
		else {
			o2Cache -= amount;
		}
		return result;
	}
	
	/**
	 * Stores the amount resource
	 * 
	 * @param amount
	 * @param resource
	 * @param source
	 * @return
	 */
	private boolean store(double amount, int resource, String source) {
		if (building.getSettlement().storeAmountResource(resource, amount) == 0)
			return true;
		return false;
	}
	
	/**
	 * Compares if the object is the same as this crop
	 */
	public boolean equals(Object obj) {
		if (this == obj) return true;
		if (obj == null) return false;
		if (this.getClass() != obj.getClass()) return false;
		Crop c = (Crop) obj;
		return this.identifier == c.getIdentifier();
	}
	
	/**
	 * Reloads instances after loading from a saved sim
	 * @param cropConfig2 
	 * 
	 * @param {@link MasterClock}
	 * @param {{@link MarsClock}
	 */
	public static void initializeInstances(CropConfig cropConfig2) {
		cropConfig = cropConfig2;
	}
	
	/**
	 * Prepare object for garbage collection.
	 */
	public void destroy() {
		phaseType = null;
		farm = null;

	}

	@Override
	public String toString() {
		return "Crop [cropSpec.getName()=" + cropSpec.getName() + " @ " + building + "]";
	}

	@Override
	public int compareTo(Crop o) {
		return cropSpec.getName().compareTo(o.getCropName());
	}

	/**
	 * Crop need power in any phase that is not the first or last
	 * @return
	 */
	public boolean needsPower() {
		int currentPhaseNum = getCurrentPhaseNum();
		return ((currentPhaseNum == 2)
				|| (currentPhaseNum > 2 && currentPhaseNum < cropSpec.getPhases().size() - 1));
	}
}
